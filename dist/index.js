!function(r,g){"object"==typeof exports&&"object"==typeof module?module.exports=g():"function"==typeof define&&define.amd?define([],g):"object"==typeof exports?exports["state-update-builder"]=g():r["state-update-builder"]=g()}(this,function(){return function(r){function g(c){if(n[c])return n[c].exports;var l=n[c]={exports:{},id:c,loaded:!1};return r[c].call(l.exports,l,l.exports,g),l.loaded=!0,l.exports}var n={};return g.m=r,g.c=n,g.p="",g(0)}([function(module,exports){eval("const defaultOptions = {\r\n    enableWarnings: false,\r\n    errorsLog: true\r\n};\r\n\r\n\r\n//TODO: ad warnings\r\nexport default class StateUpdateBuilder {\r\n    constructor(state, options) {\r\n        if (state == undefined)\r\n            console.error('root cannot be null');\r\n\r\n        this._options = Object.assign({}, defaultOptions, options);\r\n\r\n        this.current = this.extendNode(state);\r\n        this.origin = state;\r\n        this.parent = undefined;\r\n        this.parent = undefined;\r\n        this._updated = false;\r\n        this._lastNode = undefined;\r\n        this._refLabel = undefined;\r\n    }\r\n\r\n    //generate a StateUpdateBuilder as passing current root as an\r\n    initChildBuider(newOrigin, lastNode, label) {\r\n        var childBuilder = new StateUpdateBuilder(newOrigin, this._options);\r\n\r\n        //propagate parent builder informations\r\n        childBuilder.parent = this;\r\n        childBuilder._lastNode = lastNode;\r\n        childBuilder._refLabel = label;\r\n\r\n        return childBuilder;\r\n    }\r\n\r\n    //creates new reference for arrays, objects and functions\r\n    extendNode(node) {\r\n        if (Array.isArray(node))\r\n            return [].concat(node);\r\n\r\n        if (typeof node === 'object')\r\n            return Object.assign({}, node);\r\n\r\n        if (typeof node === 'function')\r\n            return ()=> node();\r\n\r\n        return node\r\n    }\r\n\r\n    //traverse single node object\r\n    traverseNode(label) {\r\n        if (this._treeError) return this;\r\n\r\n        var node = this.current[label];\r\n        if (checkNodeUndefined.call(this, node, label))\r\n            return this;\r\n\r\n        //create new builder with shallow copy of traversed node\r\n        var resultBuilder = this.initChildBuider(node, this.current, label);\r\n\r\n        //assign node copy to parent pointer\r\n        this.current[label] = resultBuilder.current;\r\n\r\n        //returns new builder\r\n        return resultBuilder;\r\n    }\r\n\r\n    //traverse single array object navigate to array instance\r\n    traverseList(label, lambda) {\r\n        if (this._treeError) return this;\r\n\r\n        var node = this.current[label];\r\n\r\n        if (checkNodeUndefined.call(this, node, label) || checkNodeNotArray.call(this, node, label)) {\r\n            this.propagateError(true);\r\n            return this;\r\n        }\r\n\r\n        var choosePath = (el, i)=> typeof lambda === 'function' ? lambda(el, i) : true;\r\n        var elemIndex = node.findIndex(choosePath);\r\n\r\n        if (checkListItemUndefined.call(this, elemIndex, label)) return this;\r\n\r\n        var lastNode = this.extendNode(node);\r\n        //create new builder positioned on item found\r\n        var resultBuilder = this.initChildBuider(node.find(choosePath), lastNode, elemIndex);\r\n\r\n        //generate new reference to current node array\r\n        this.current[label] = lastNode;\r\n        this.current[label][elemIndex] = resultBuilder.current;\r\n\r\n        return resultBuilder;\r\n    }\r\n\r\n    //UPDATE OPERATIONS\r\n    //{$set: any} replace the target entirely.\r\n    set(label, value) {\r\n        if (this._treeError) return this;\r\n\r\n        if (_DEV_ && this._options.enableWarnings && this.current[label] === undefined && label !== null)\r\n            console.error('SUB - Warning: node \"' + label + '\" not found');\r\n\r\n        this.propagateUpdate(this._updated || this.current[label] !== value);\r\n        this.current[label] = value;\r\n\r\n\r\n        return this;\r\n    }\r\n\r\n    setNode(node) {\r\n        if (this._treeError) return this;\r\n\r\n        if (!this._lastNode) {\r\n            this.current = node;\r\n            this.propagateUpdate(this._updated || this.current !== node);\r\n        }\r\n        else {\r\n            this._lastNode[this._refLabel] = node;\r\n            this.propagateUpdate(this._updated || this._lastNode[this._refLabel] !== node);\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    //{$merge: object} merge the keys of object with the target.\r\n    merge(label, value) {\r\n        if (this._treeError) return this;\r\n\r\n        if (this._options.enableWarnings && typeof value !== 'object') {\r\n            console.error('SUB - Warning: \"value\" is not an object');\r\n            return this;\r\n        }\r\n\r\n        var node = this.current[label];\r\n\r\n        this.propagateUpdate(this._updated || Object.keys(value).reduce((p, c) => p || node[c] !== value[c], false));\r\n\r\n        this.current[label] = Object.assign(node, value);\r\n\r\n\r\n        return this;\r\n    }\r\n\r\n    mergeNode(node) {\r\n        if (this._treeError) return this;\r\n\r\n        var elem = this._lastNode ? this._lastNode[this._refLabel] : this.current;\r\n        this.propagateUpdate(this._updated || Object.keys(node).reduce((p, c) => p || elem[c] !== node[c], false));\r\n\r\n        if (!this._lastNode) {\r\n            this.current = Object.assign(this.current, node);\r\n        }\r\n        else\r\n            this._lastNode[this._refLabel] = Object.assign(this._lastNode[this._refLabel], node);\r\n\r\n        return this;\r\n    }\r\n\r\n    //remove child node of current object/array node\r\n    removeNode(label, lambda) {\r\n        var node = this.current[label];\r\n\r\n        if (node == undefined) return this;\r\n\r\n        if (Array.isArray(node) && typeof lambda === 'function') {\r\n            var elemIndex = node.findIndex(lambda);\r\n            this.current[label].splice(elemIndex, 1);\r\n            return this;\r\n        }\r\n\r\n        this.current[label] = undefined;\r\n        this.propagateUpdate(true);\r\n\r\n        return this;\r\n    }\r\n\r\n    //{$apply: function} passes in the current value to the function and updates it with the new returned value.\r\n    apply(label, fn) {\r\n        if (this._treeError) return this;\r\n\r\n        var node = this.current[label];\r\n        if (checkNodeUndefined.call(this, node, label) || checkNotFunction.call(this, fn))\r\n            return this;\r\n\r\n        this.current[label] = fn(this.extendNode(node));\r\n\r\n        this.propagateUpdate(this._updated || node !== this.current[label]);\r\n\r\n        return this;\r\n    }\r\n\r\n    //{$push: array} push() all the items in array on the target.\r\n    push(label, array) {\r\n        if (this._treeError) return this;\r\n        var node = this.current[label];\r\n        if (checkNodeUndefined.call(this, node, label) || checkNodeNotArray.call(this, array, label))\r\n            return this;\r\n\r\n        var newNode = this.current[label] = this.extendNode(node);\r\n        Array.prototype.push.apply(newNode, array);\r\n        this.propagateUpdate(true);\r\n\r\n        return this; //returns the same builder\r\n\r\n\r\n    }\r\n\r\n    //{$unshift: array} unshift() all the items in array on the target.\r\n    unshift(label, array) {\r\n        if (this._treeError) return this;\r\n        var node = this.current[label];\r\n        if (checkNodeUndefined.call(this, node, label) || checkNodeNotArray.call(this, array, label))\r\n            return this;\r\n\r\n        var newNode = this.current[label] = this.extendNode(node);\r\n        Array.prototype.unshift.apply(newNode, array);\r\n        this.propagateUpdate(this._updated || array.length > 0);\r\n\r\n        return this; //returns the same builder\r\n    }\r\n\r\n    //{$splice: array of arrays} for each item in arrays call splice() on the target with the parameters provided by the item.\r\n    splice(label, array) {\r\n        if (this._treeError) return this;\r\n        var node = this.current[label];\r\n        if (checkNodeUndefined.call(this, node, label) || checkNodeNotArray.call(this, array, label))\r\n            return this;\r\n\r\n        var newNode = this.current[label] = this.extendNode(node);\r\n        Array.prototype.splice.apply(newNode, array);\r\n\r\n        this.propagateUpdate(this._updated || array.length > 0);\r\n\r\n        return this; //returns the same builder\r\n    }\r\n\r\n    splice(label, ...args) {\r\n        if (this._treeError) return this;\r\n        var node = this.current[label];\r\n        if (checkNodeUndefined.call(this, node, label) || checkNodeNotArray.call(this, node, label))\r\n            return this;\r\n\r\n        var newNode = this.current[label] = this.extendNode(node);\r\n        Array.prototype.splice.apply(newNode, args);\r\n\r\n        this.propagateUpdate(this._updated || args.length > 0);\r\n\r\n        return this; //returns the same builder\r\n    }\r\n\r\n\r\n    execute() {\r\n        return this.parent\r\n            ? this.parent.execute()\r\n            : this._treeError ? this.origin : this.current;\r\n    }\r\n\r\n    checkError() {\r\n        return this._treeError;\r\n    }\r\n\r\n    propagateUpdate(update) {\r\n        this._updated = update;\r\n        if(update)\r\n            this.parent && this.parent.propagateUpdate(update);\r\n    };\r\n\r\n    propagateError(error) {\r\n        this._treeError = error;\r\n        this.parent && this.parent.propagateError(error);\r\n    };\r\n\r\n    resetError() {\r\n        this.propagateError(false);\r\n        return this;\r\n    }\r\n\r\n    checkNodeUpdated() {\r\n        return this._updated;\r\n    }\r\n\r\n    pruneSubtree(label) {\r\n        if (this._treeError) return this;\r\n\r\n        var node = this.current[label];\r\n        if (_DEV_ && this._options.enableWarnings && node === undefined && label !== null)\r\n            console.error('SUB - Warning: node \"' + label + '\" not found');\r\n\r\n        if (node != undefined)\r\n            this.current[label] = this.origin[label];\r\n        else {\r\n            if (this._lastNode == undefined) {\r\n                if (this._options.errorsLog)\r\n                    console.error('SUB - Error: cannot prune node root');\r\n            }\r\n            else\r\n                this._lastNode[this._refLabel] = this.origin;\r\n        }\r\n        return this.parent || this;\r\n    }\r\n}\r\n\r\n///ERROR CHECK AND NOTIFICATION\r\nfunction checkNodeUndefined(node, label) {\r\n    if (node != undefined) return false;\r\n\r\n    this.propagateError(true);\r\n    if (this._options.errorsLog)\r\n        console.error('SUB - Error: node \"' + label + '\" not found');\r\n    return true;\r\n}\r\nfunction checkListItemUndefined(elemIndex, label) {\r\n    if (elemIndex !== -1) return false;\r\n\r\n    this.propagateError(true);\r\n    if (this._options.errorsLog)\r\n        console.error('SUB - Error: elem of list \"' + label + '\" not found');\r\n    return true;\r\n}\r\n\r\nfunction checkNodeNotArray(node, label) {\r\n    if (Array.isArray(node)) return false;\r\n\r\n    this.propagateError(true);\r\n    if (this._options.errorsLog)\r\n        console.error('SUB - Error: node \"' + label + '\" is not an array');\r\n    return true;\r\n}\r\n\r\nfunction checkNotFunction(fn) {\r\n    if (typeof fn === 'function') return false;\r\n\r\n    this.propagateError(true);\r\n    if (this._options.errorsLog)\r\n        console.error('SUB - Error: parameter \"fn\" is not a function');\r\n    return true;\r\n}\r\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9pbmRleC5qcz85NTUyIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IGRlZmF1bHRPcHRpb25zID0ge1xyXG4gICAgZW5hYmxlV2FybmluZ3M6IGZhbHNlLFxyXG4gICAgZXJyb3JzTG9nOiB0cnVlXHJcbn07XHJcblxyXG5cclxuLy9UT0RPOiBhZCB3YXJuaW5nc1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTdGF0ZVVwZGF0ZUJ1aWxkZXIge1xyXG4gICAgY29uc3RydWN0b3Ioc3RhdGUsIG9wdGlvbnMpIHtcclxuICAgICAgICBpZiAoc3RhdGUgPT0gdW5kZWZpbmVkKVxyXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdyb290IGNhbm5vdCBiZSBudWxsJyk7XHJcblxyXG4gICAgICAgIHRoaXMuX29wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0T3B0aW9ucywgb3B0aW9ucyk7XHJcblxyXG4gICAgICAgIHRoaXMuY3VycmVudCA9IHRoaXMuZXh0ZW5kTm9kZShzdGF0ZSk7XHJcbiAgICAgICAgdGhpcy5vcmlnaW4gPSBzdGF0ZTtcclxuICAgICAgICB0aGlzLnBhcmVudCA9IHVuZGVmaW5lZDtcclxuICAgICAgICB0aGlzLnBhcmVudCA9IHVuZGVmaW5lZDtcclxuICAgICAgICB0aGlzLl91cGRhdGVkID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5fbGFzdE5vZGUgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgdGhpcy5fcmVmTGFiZWwgPSB1bmRlZmluZWQ7XHJcbiAgICB9XHJcblxyXG4gICAgLy9nZW5lcmF0ZSBhIFN0YXRlVXBkYXRlQnVpbGRlciBhcyBwYXNzaW5nIGN1cnJlbnQgcm9vdCBhcyBhblxyXG4gICAgaW5pdENoaWxkQnVpZGVyKG5ld09yaWdpbiwgbGFzdE5vZGUsIGxhYmVsKSB7XHJcbiAgICAgICAgdmFyIGNoaWxkQnVpbGRlciA9IG5ldyBTdGF0ZVVwZGF0ZUJ1aWxkZXIobmV3T3JpZ2luLCB0aGlzLl9vcHRpb25zKTtcclxuXHJcbiAgICAgICAgLy9wcm9wYWdhdGUgcGFyZW50IGJ1aWxkZXIgaW5mb3JtYXRpb25zXHJcbiAgICAgICAgY2hpbGRCdWlsZGVyLnBhcmVudCA9IHRoaXM7XHJcbiAgICAgICAgY2hpbGRCdWlsZGVyLl9sYXN0Tm9kZSA9IGxhc3ROb2RlO1xyXG4gICAgICAgIGNoaWxkQnVpbGRlci5fcmVmTGFiZWwgPSBsYWJlbDtcclxuXHJcbiAgICAgICAgcmV0dXJuIGNoaWxkQnVpbGRlcjtcclxuICAgIH1cclxuXHJcbiAgICAvL2NyZWF0ZXMgbmV3IHJlZmVyZW5jZSBmb3IgYXJyYXlzLCBvYmplY3RzIGFuZCBmdW5jdGlvbnNcclxuICAgIGV4dGVuZE5vZGUobm9kZSkge1xyXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KG5vZGUpKVxyXG4gICAgICAgICAgICByZXR1cm4gW10uY29uY2F0KG5vZGUpO1xyXG5cclxuICAgICAgICBpZiAodHlwZW9mIG5vZGUgPT09ICdvYmplY3QnKVxyXG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgbm9kZSk7XHJcblxyXG4gICAgICAgIGlmICh0eXBlb2Ygbm9kZSA9PT0gJ2Z1bmN0aW9uJylcclxuICAgICAgICAgICAgcmV0dXJuICgpPT4gbm9kZSgpO1xyXG5cclxuICAgICAgICByZXR1cm4gbm9kZVxyXG4gICAgfVxyXG5cclxuICAgIC8vdHJhdmVyc2Ugc2luZ2xlIG5vZGUgb2JqZWN0XHJcbiAgICB0cmF2ZXJzZU5vZGUobGFiZWwpIHtcclxuICAgICAgICBpZiAodGhpcy5fdHJlZUVycm9yKSByZXR1cm4gdGhpcztcclxuXHJcbiAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmN1cnJlbnRbbGFiZWxdO1xyXG4gICAgICAgIGlmIChjaGVja05vZGVVbmRlZmluZWQuY2FsbCh0aGlzLCBub2RlLCBsYWJlbCkpXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgICAgICAvL2NyZWF0ZSBuZXcgYnVpbGRlciB3aXRoIHNoYWxsb3cgY29weSBvZiB0cmF2ZXJzZWQgbm9kZVxyXG4gICAgICAgIHZhciByZXN1bHRCdWlsZGVyID0gdGhpcy5pbml0Q2hpbGRCdWlkZXIobm9kZSwgdGhpcy5jdXJyZW50LCBsYWJlbCk7XHJcblxyXG4gICAgICAgIC8vYXNzaWduIG5vZGUgY29weSB0byBwYXJlbnQgcG9pbnRlclxyXG4gICAgICAgIHRoaXMuY3VycmVudFtsYWJlbF0gPSByZXN1bHRCdWlsZGVyLmN1cnJlbnQ7XHJcblxyXG4gICAgICAgIC8vcmV0dXJucyBuZXcgYnVpbGRlclxyXG4gICAgICAgIHJldHVybiByZXN1bHRCdWlsZGVyO1xyXG4gICAgfVxyXG5cclxuICAgIC8vdHJhdmVyc2Ugc2luZ2xlIGFycmF5IG9iamVjdCBuYXZpZ2F0ZSB0byBhcnJheSBpbnN0YW5jZVxyXG4gICAgdHJhdmVyc2VMaXN0KGxhYmVsLCBsYW1iZGEpIHtcclxuICAgICAgICBpZiAodGhpcy5fdHJlZUVycm9yKSByZXR1cm4gdGhpcztcclxuXHJcbiAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmN1cnJlbnRbbGFiZWxdO1xyXG5cclxuICAgICAgICBpZiAoY2hlY2tOb2RlVW5kZWZpbmVkLmNhbGwodGhpcywgbm9kZSwgbGFiZWwpIHx8IGNoZWNrTm9kZU5vdEFycmF5LmNhbGwodGhpcywgbm9kZSwgbGFiZWwpKSB7XHJcbiAgICAgICAgICAgIHRoaXMucHJvcGFnYXRlRXJyb3IodHJ1ZSk7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIGNob29zZVBhdGggPSAoZWwsIGkpPT4gdHlwZW9mIGxhbWJkYSA9PT0gJ2Z1bmN0aW9uJyA/IGxhbWJkYShlbCwgaSkgOiB0cnVlO1xyXG4gICAgICAgIHZhciBlbGVtSW5kZXggPSBub2RlLmZpbmRJbmRleChjaG9vc2VQYXRoKTtcclxuXHJcbiAgICAgICAgaWYgKGNoZWNrTGlzdEl0ZW1VbmRlZmluZWQuY2FsbCh0aGlzLCBlbGVtSW5kZXgsIGxhYmVsKSkgcmV0dXJuIHRoaXM7XHJcblxyXG4gICAgICAgIHZhciBsYXN0Tm9kZSA9IHRoaXMuZXh0ZW5kTm9kZShub2RlKTtcclxuICAgICAgICAvL2NyZWF0ZSBuZXcgYnVpbGRlciBwb3NpdGlvbmVkIG9uIGl0ZW0gZm91bmRcclxuICAgICAgICB2YXIgcmVzdWx0QnVpbGRlciA9IHRoaXMuaW5pdENoaWxkQnVpZGVyKG5vZGUuZmluZChjaG9vc2VQYXRoKSwgbGFzdE5vZGUsIGVsZW1JbmRleCk7XHJcblxyXG4gICAgICAgIC8vZ2VuZXJhdGUgbmV3IHJlZmVyZW5jZSB0byBjdXJyZW50IG5vZGUgYXJyYXlcclxuICAgICAgICB0aGlzLmN1cnJlbnRbbGFiZWxdID0gbGFzdE5vZGU7XHJcbiAgICAgICAgdGhpcy5jdXJyZW50W2xhYmVsXVtlbGVtSW5kZXhdID0gcmVzdWx0QnVpbGRlci5jdXJyZW50O1xyXG5cclxuICAgICAgICByZXR1cm4gcmVzdWx0QnVpbGRlcjtcclxuICAgIH1cclxuXHJcbiAgICAvL1VQREFURSBPUEVSQVRJT05TXHJcbiAgICAvL3skc2V0OiBhbnl9IHJlcGxhY2UgdGhlIHRhcmdldCBlbnRpcmVseS5cclxuICAgIHNldChsYWJlbCwgdmFsdWUpIHtcclxuICAgICAgICBpZiAodGhpcy5fdHJlZUVycm9yKSByZXR1cm4gdGhpcztcclxuXHJcbiAgICAgICAgaWYgKF9ERVZfICYmIHRoaXMuX29wdGlvbnMuZW5hYmxlV2FybmluZ3MgJiYgdGhpcy5jdXJyZW50W2xhYmVsXSA9PT0gdW5kZWZpbmVkICYmIGxhYmVsICE9PSBudWxsKVxyXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdTVUIgLSBXYXJuaW5nOiBub2RlIFwiJyArIGxhYmVsICsgJ1wiIG5vdCBmb3VuZCcpO1xyXG5cclxuICAgICAgICB0aGlzLnByb3BhZ2F0ZVVwZGF0ZSh0aGlzLl91cGRhdGVkIHx8IHRoaXMuY3VycmVudFtsYWJlbF0gIT09IHZhbHVlKTtcclxuICAgICAgICB0aGlzLmN1cnJlbnRbbGFiZWxdID0gdmFsdWU7XHJcblxyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuXHJcbiAgICBzZXROb2RlKG5vZGUpIHtcclxuICAgICAgICBpZiAodGhpcy5fdHJlZUVycm9yKSByZXR1cm4gdGhpcztcclxuXHJcbiAgICAgICAgaWYgKCF0aGlzLl9sYXN0Tm9kZSkge1xyXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnQgPSBub2RlO1xyXG4gICAgICAgICAgICB0aGlzLnByb3BhZ2F0ZVVwZGF0ZSh0aGlzLl91cGRhdGVkIHx8IHRoaXMuY3VycmVudCAhPT0gbm9kZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLl9sYXN0Tm9kZVt0aGlzLl9yZWZMYWJlbF0gPSBub2RlO1xyXG4gICAgICAgICAgICB0aGlzLnByb3BhZ2F0ZVVwZGF0ZSh0aGlzLl91cGRhdGVkIHx8IHRoaXMuX2xhc3ROb2RlW3RoaXMuX3JlZkxhYmVsXSAhPT0gbm9kZSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuXHJcbiAgICAvL3skbWVyZ2U6IG9iamVjdH0gbWVyZ2UgdGhlIGtleXMgb2Ygb2JqZWN0IHdpdGggdGhlIHRhcmdldC5cclxuICAgIG1lcmdlKGxhYmVsLCB2YWx1ZSkge1xyXG4gICAgICAgIGlmICh0aGlzLl90cmVlRXJyb3IpIHJldHVybiB0aGlzO1xyXG5cclxuICAgICAgICBpZiAodGhpcy5fb3B0aW9ucy5lbmFibGVXYXJuaW5ncyAmJiB0eXBlb2YgdmFsdWUgIT09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1NVQiAtIFdhcm5pbmc6IFwidmFsdWVcIiBpcyBub3QgYW4gb2JqZWN0Jyk7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmN1cnJlbnRbbGFiZWxdO1xyXG5cclxuICAgICAgICB0aGlzLnByb3BhZ2F0ZVVwZGF0ZSh0aGlzLl91cGRhdGVkIHx8IE9iamVjdC5rZXlzKHZhbHVlKS5yZWR1Y2UoKHAsIGMpID0+IHAgfHwgbm9kZVtjXSAhPT0gdmFsdWVbY10sIGZhbHNlKSk7XHJcblxyXG4gICAgICAgIHRoaXMuY3VycmVudFtsYWJlbF0gPSBPYmplY3QuYXNzaWduKG5vZGUsIHZhbHVlKTtcclxuXHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG5cclxuICAgIG1lcmdlTm9kZShub2RlKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX3RyZWVFcnJvcikgcmV0dXJuIHRoaXM7XHJcblxyXG4gICAgICAgIHZhciBlbGVtID0gdGhpcy5fbGFzdE5vZGUgPyB0aGlzLl9sYXN0Tm9kZVt0aGlzLl9yZWZMYWJlbF0gOiB0aGlzLmN1cnJlbnQ7XHJcbiAgICAgICAgdGhpcy5wcm9wYWdhdGVVcGRhdGUodGhpcy5fdXBkYXRlZCB8fCBPYmplY3Qua2V5cyhub2RlKS5yZWR1Y2UoKHAsIGMpID0+IHAgfHwgZWxlbVtjXSAhPT0gbm9kZVtjXSwgZmFsc2UpKTtcclxuXHJcbiAgICAgICAgaWYgKCF0aGlzLl9sYXN0Tm9kZSkge1xyXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnQgPSBPYmplY3QuYXNzaWduKHRoaXMuY3VycmVudCwgbm9kZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2VcclxuICAgICAgICAgICAgdGhpcy5fbGFzdE5vZGVbdGhpcy5fcmVmTGFiZWxdID0gT2JqZWN0LmFzc2lnbih0aGlzLl9sYXN0Tm9kZVt0aGlzLl9yZWZMYWJlbF0sIG5vZGUpO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuXHJcbiAgICAvL3JlbW92ZSBjaGlsZCBub2RlIG9mIGN1cnJlbnQgb2JqZWN0L2FycmF5IG5vZGVcclxuICAgIHJlbW92ZU5vZGUobGFiZWwsIGxhbWJkYSkge1xyXG4gICAgICAgIHZhciBub2RlID0gdGhpcy5jdXJyZW50W2xhYmVsXTtcclxuXHJcbiAgICAgICAgaWYgKG5vZGUgPT0gdW5kZWZpbmVkKSByZXR1cm4gdGhpcztcclxuXHJcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkobm9kZSkgJiYgdHlwZW9mIGxhbWJkYSA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICB2YXIgZWxlbUluZGV4ID0gbm9kZS5maW5kSW5kZXgobGFtYmRhKTtcclxuICAgICAgICAgICAgdGhpcy5jdXJyZW50W2xhYmVsXS5zcGxpY2UoZWxlbUluZGV4LCAxKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLmN1cnJlbnRbbGFiZWxdID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIHRoaXMucHJvcGFnYXRlVXBkYXRlKHRydWUpO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuXHJcbiAgICAvL3skYXBwbHk6IGZ1bmN0aW9ufSBwYXNzZXMgaW4gdGhlIGN1cnJlbnQgdmFsdWUgdG8gdGhlIGZ1bmN0aW9uIGFuZCB1cGRhdGVzIGl0IHdpdGggdGhlIG5ldyByZXR1cm5lZCB2YWx1ZS5cclxuICAgIGFwcGx5KGxhYmVsLCBmbikge1xyXG4gICAgICAgIGlmICh0aGlzLl90cmVlRXJyb3IpIHJldHVybiB0aGlzO1xyXG5cclxuICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3VycmVudFtsYWJlbF07XHJcbiAgICAgICAgaWYgKGNoZWNrTm9kZVVuZGVmaW5lZC5jYWxsKHRoaXMsIG5vZGUsIGxhYmVsKSB8fCBjaGVja05vdEZ1bmN0aW9uLmNhbGwodGhpcywgZm4pKVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuXHJcbiAgICAgICAgdGhpcy5jdXJyZW50W2xhYmVsXSA9IGZuKHRoaXMuZXh0ZW5kTm9kZShub2RlKSk7XHJcblxyXG4gICAgICAgIHRoaXMucHJvcGFnYXRlVXBkYXRlKHRoaXMuX3VwZGF0ZWQgfHwgbm9kZSAhPT0gdGhpcy5jdXJyZW50W2xhYmVsXSk7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG5cclxuICAgIC8veyRwdXNoOiBhcnJheX0gcHVzaCgpIGFsbCB0aGUgaXRlbXMgaW4gYXJyYXkgb24gdGhlIHRhcmdldC5cclxuICAgIHB1c2gobGFiZWwsIGFycmF5KSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX3RyZWVFcnJvcikgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmN1cnJlbnRbbGFiZWxdO1xyXG4gICAgICAgIGlmIChjaGVja05vZGVVbmRlZmluZWQuY2FsbCh0aGlzLCBub2RlLCBsYWJlbCkgfHwgY2hlY2tOb2RlTm90QXJyYXkuY2FsbCh0aGlzLCBhcnJheSwgbGFiZWwpKVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuXHJcbiAgICAgICAgdmFyIG5ld05vZGUgPSB0aGlzLmN1cnJlbnRbbGFiZWxdID0gdGhpcy5leHRlbmROb2RlKG5vZGUpO1xyXG4gICAgICAgIEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KG5ld05vZGUsIGFycmF5KTtcclxuICAgICAgICB0aGlzLnByb3BhZ2F0ZVVwZGF0ZSh0cnVlKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7IC8vcmV0dXJucyB0aGUgc2FtZSBidWlsZGVyXHJcblxyXG5cclxuICAgIH1cclxuXHJcbiAgICAvL3skdW5zaGlmdDogYXJyYXl9IHVuc2hpZnQoKSBhbGwgdGhlIGl0ZW1zIGluIGFycmF5IG9uIHRoZSB0YXJnZXQuXHJcbiAgICB1bnNoaWZ0KGxhYmVsLCBhcnJheSkge1xyXG4gICAgICAgIGlmICh0aGlzLl90cmVlRXJyb3IpIHJldHVybiB0aGlzO1xyXG4gICAgICAgIHZhciBub2RlID0gdGhpcy5jdXJyZW50W2xhYmVsXTtcclxuICAgICAgICBpZiAoY2hlY2tOb2RlVW5kZWZpbmVkLmNhbGwodGhpcywgbm9kZSwgbGFiZWwpIHx8IGNoZWNrTm9kZU5vdEFycmF5LmNhbGwodGhpcywgYXJyYXksIGxhYmVsKSlcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcblxyXG4gICAgICAgIHZhciBuZXdOb2RlID0gdGhpcy5jdXJyZW50W2xhYmVsXSA9IHRoaXMuZXh0ZW5kTm9kZShub2RlKTtcclxuICAgICAgICBBcnJheS5wcm90b3R5cGUudW5zaGlmdC5hcHBseShuZXdOb2RlLCBhcnJheSk7XHJcbiAgICAgICAgdGhpcy5wcm9wYWdhdGVVcGRhdGUodGhpcy5fdXBkYXRlZCB8fCBhcnJheS5sZW5ndGggPiAwKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7IC8vcmV0dXJucyB0aGUgc2FtZSBidWlsZGVyXHJcbiAgICB9XHJcblxyXG4gICAgLy97JHNwbGljZTogYXJyYXkgb2YgYXJyYXlzfSBmb3IgZWFjaCBpdGVtIGluIGFycmF5cyBjYWxsIHNwbGljZSgpIG9uIHRoZSB0YXJnZXQgd2l0aCB0aGUgcGFyYW1ldGVycyBwcm92aWRlZCBieSB0aGUgaXRlbS5cclxuICAgIHNwbGljZShsYWJlbCwgYXJyYXkpIHtcclxuICAgICAgICBpZiAodGhpcy5fdHJlZUVycm9yKSByZXR1cm4gdGhpcztcclxuICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3VycmVudFtsYWJlbF07XHJcbiAgICAgICAgaWYgKGNoZWNrTm9kZVVuZGVmaW5lZC5jYWxsKHRoaXMsIG5vZGUsIGxhYmVsKSB8fCBjaGVja05vZGVOb3RBcnJheS5jYWxsKHRoaXMsIGFycmF5LCBsYWJlbCkpXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgICAgICB2YXIgbmV3Tm9kZSA9IHRoaXMuY3VycmVudFtsYWJlbF0gPSB0aGlzLmV4dGVuZE5vZGUobm9kZSk7XHJcbiAgICAgICAgQXJyYXkucHJvdG90eXBlLnNwbGljZS5hcHBseShuZXdOb2RlLCBhcnJheSk7XHJcblxyXG4gICAgICAgIHRoaXMucHJvcGFnYXRlVXBkYXRlKHRoaXMuX3VwZGF0ZWQgfHwgYXJyYXkubGVuZ3RoID4gMCk7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzOyAvL3JldHVybnMgdGhlIHNhbWUgYnVpbGRlclxyXG4gICAgfVxyXG5cclxuICAgIHNwbGljZShsYWJlbCwgLi4uYXJncykge1xyXG4gICAgICAgIGlmICh0aGlzLl90cmVlRXJyb3IpIHJldHVybiB0aGlzO1xyXG4gICAgICAgIHZhciBub2RlID0gdGhpcy5jdXJyZW50W2xhYmVsXTtcclxuICAgICAgICBpZiAoY2hlY2tOb2RlVW5kZWZpbmVkLmNhbGwodGhpcywgbm9kZSwgbGFiZWwpIHx8IGNoZWNrTm9kZU5vdEFycmF5LmNhbGwodGhpcywgbm9kZSwgbGFiZWwpKVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuXHJcbiAgICAgICAgdmFyIG5ld05vZGUgPSB0aGlzLmN1cnJlbnRbbGFiZWxdID0gdGhpcy5leHRlbmROb2RlKG5vZGUpO1xyXG4gICAgICAgIEFycmF5LnByb3RvdHlwZS5zcGxpY2UuYXBwbHkobmV3Tm9kZSwgYXJncyk7XHJcblxyXG4gICAgICAgIHRoaXMucHJvcGFnYXRlVXBkYXRlKHRoaXMuX3VwZGF0ZWQgfHwgYXJncy5sZW5ndGggPiAwKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7IC8vcmV0dXJucyB0aGUgc2FtZSBidWlsZGVyXHJcbiAgICB9XHJcblxyXG5cclxuICAgIGV4ZWN1dGUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyZW50XHJcbiAgICAgICAgICAgID8gdGhpcy5wYXJlbnQuZXhlY3V0ZSgpXHJcbiAgICAgICAgICAgIDogdGhpcy5fdHJlZUVycm9yID8gdGhpcy5vcmlnaW4gOiB0aGlzLmN1cnJlbnQ7XHJcbiAgICB9XHJcblxyXG4gICAgY2hlY2tFcnJvcigpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fdHJlZUVycm9yO1xyXG4gICAgfVxyXG5cclxuICAgIHByb3BhZ2F0ZVVwZGF0ZSh1cGRhdGUpIHtcclxuICAgICAgICB0aGlzLl91cGRhdGVkID0gdXBkYXRlO1xyXG4gICAgICAgIGlmKHVwZGF0ZSlcclxuICAgICAgICAgICAgdGhpcy5wYXJlbnQgJiYgdGhpcy5wYXJlbnQucHJvcGFnYXRlVXBkYXRlKHVwZGF0ZSk7XHJcbiAgICB9O1xyXG5cclxuICAgIHByb3BhZ2F0ZUVycm9yKGVycm9yKSB7XHJcbiAgICAgICAgdGhpcy5fdHJlZUVycm9yID0gZXJyb3I7XHJcbiAgICAgICAgdGhpcy5wYXJlbnQgJiYgdGhpcy5wYXJlbnQucHJvcGFnYXRlRXJyb3IoZXJyb3IpO1xyXG4gICAgfTtcclxuXHJcbiAgICByZXNldEVycm9yKCkge1xyXG4gICAgICAgIHRoaXMucHJvcGFnYXRlRXJyb3IoZmFsc2UpO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG5cclxuICAgIGNoZWNrTm9kZVVwZGF0ZWQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3VwZGF0ZWQ7XHJcbiAgICB9XHJcblxyXG4gICAgcHJ1bmVTdWJ0cmVlKGxhYmVsKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX3RyZWVFcnJvcikgcmV0dXJuIHRoaXM7XHJcblxyXG4gICAgICAgIHZhciBub2RlID0gdGhpcy5jdXJyZW50W2xhYmVsXTtcclxuICAgICAgICBpZiAoX0RFVl8gJiYgdGhpcy5fb3B0aW9ucy5lbmFibGVXYXJuaW5ncyAmJiBub2RlID09PSB1bmRlZmluZWQgJiYgbGFiZWwgIT09IG51bGwpXHJcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1NVQiAtIFdhcm5pbmc6IG5vZGUgXCInICsgbGFiZWwgKyAnXCIgbm90IGZvdW5kJyk7XHJcblxyXG4gICAgICAgIGlmIChub2RlICE9IHVuZGVmaW5lZClcclxuICAgICAgICAgICAgdGhpcy5jdXJyZW50W2xhYmVsXSA9IHRoaXMub3JpZ2luW2xhYmVsXTtcclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuX2xhc3ROb2RlID09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX29wdGlvbnMuZXJyb3JzTG9nKVxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1NVQiAtIEVycm9yOiBjYW5ub3QgcHJ1bmUgbm9kZSByb290Jyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgdGhpcy5fbGFzdE5vZGVbdGhpcy5fcmVmTGFiZWxdID0gdGhpcy5vcmlnaW47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLnBhcmVudCB8fCB0aGlzO1xyXG4gICAgfVxyXG59XHJcblxyXG4vLy9FUlJPUiBDSEVDSyBBTkQgTk9USUZJQ0FUSU9OXHJcbmZ1bmN0aW9uIGNoZWNrTm9kZVVuZGVmaW5lZChub2RlLCBsYWJlbCkge1xyXG4gICAgaWYgKG5vZGUgIT0gdW5kZWZpbmVkKSByZXR1cm4gZmFsc2U7XHJcblxyXG4gICAgdGhpcy5wcm9wYWdhdGVFcnJvcih0cnVlKTtcclxuICAgIGlmICh0aGlzLl9vcHRpb25zLmVycm9yc0xvZylcclxuICAgICAgICBjb25zb2xlLmVycm9yKCdTVUIgLSBFcnJvcjogbm9kZSBcIicgKyBsYWJlbCArICdcIiBub3QgZm91bmQnKTtcclxuICAgIHJldHVybiB0cnVlO1xyXG59XHJcbmZ1bmN0aW9uIGNoZWNrTGlzdEl0ZW1VbmRlZmluZWQoZWxlbUluZGV4LCBsYWJlbCkge1xyXG4gICAgaWYgKGVsZW1JbmRleCAhPT0gLTEpIHJldHVybiBmYWxzZTtcclxuXHJcbiAgICB0aGlzLnByb3BhZ2F0ZUVycm9yKHRydWUpO1xyXG4gICAgaWYgKHRoaXMuX29wdGlvbnMuZXJyb3JzTG9nKVxyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ1NVQiAtIEVycm9yOiBlbGVtIG9mIGxpc3QgXCInICsgbGFiZWwgKyAnXCIgbm90IGZvdW5kJyk7XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxufVxyXG5cclxuZnVuY3Rpb24gY2hlY2tOb2RlTm90QXJyYXkobm9kZSwgbGFiZWwpIHtcclxuICAgIGlmIChBcnJheS5pc0FycmF5KG5vZGUpKSByZXR1cm4gZmFsc2U7XHJcblxyXG4gICAgdGhpcy5wcm9wYWdhdGVFcnJvcih0cnVlKTtcclxuICAgIGlmICh0aGlzLl9vcHRpb25zLmVycm9yc0xvZylcclxuICAgICAgICBjb25zb2xlLmVycm9yKCdTVUIgLSBFcnJvcjogbm9kZSBcIicgKyBsYWJlbCArICdcIiBpcyBub3QgYW4gYXJyYXknKTtcclxuICAgIHJldHVybiB0cnVlO1xyXG59XHJcblxyXG5mdW5jdGlvbiBjaGVja05vdEZ1bmN0aW9uKGZuKSB7XHJcbiAgICBpZiAodHlwZW9mIGZuID09PSAnZnVuY3Rpb24nKSByZXR1cm4gZmFsc2U7XHJcblxyXG4gICAgdGhpcy5wcm9wYWdhdGVFcnJvcih0cnVlKTtcclxuICAgIGlmICh0aGlzLl9vcHRpb25zLmVycm9yc0xvZylcclxuICAgICAgICBjb25zb2xlLmVycm9yKCdTVUIgLSBFcnJvcjogcGFyYW1ldGVyIFwiZm5cIiBpcyBub3QgYSBmdW5jdGlvbicpO1xyXG4gICAgcmV0dXJuIHRydWU7XHJcbn1cclxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NyYy9pbmRleC5qc1xuICoqIG1vZHVsZSBpZCA9IDBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9")}])});