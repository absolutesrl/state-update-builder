!function(r,n){"object"==typeof exports&&"object"==typeof module?module.exports=n():"function"==typeof define&&define.amd?define([],n):"object"==typeof exports?exports["state-update-builder"]=n():r["state-update-builder"]=n()}(this,function(){return function(r){function n(e){if(c[e])return c[e].exports;var g=c[e]={i:e,l:!1,exports:{}};return r[e].call(g.exports,g,g.exports,n),g.l=!0,g.exports}var c={};return n.m=r,n.c=c,n.i=function(r){return r},n.d=function(r,c,e){n.o(r,c)||Object.defineProperty(r,c,{configurable:!1,enumerable:!0,get:e})},n.n=function(r){var c=r&&r.__esModule?function(){return r.default}:function(){return r};return n.d(c,"a",c),c},n.o=function(r,n){return Object.prototype.hasOwnProperty.call(r,n)},n.p="",n(n.s=0)}([function(module,__webpack_exports__,__webpack_require__){"use strict";eval("Object.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\nconst defaultOptions = {\r\n    enableWarnings: false,\r\n    errorsLog: true\r\n};\r\n\r\n\r\n//TODO: ad warnings\r\nclass StateUpdateBuilder {\r\n    constructor(state, options) {\r\n        if (state == undefined)\r\n            console.error('root cannot be null');\r\n\r\n        this._options = Object.assign({}, defaultOptions, options);\r\n\r\n        this.current = this.extendNode(state);\r\n        this.origin = state;\r\n        this.parent = undefined;\r\n        this.parent = undefined;\r\n        this._updated = false;\r\n        this._lastNode = undefined;\r\n        this._refLabel = undefined;\r\n    }\r\n\r\n    //generate a StateUpdateBuilder as passing current root as an\r\n    initChildBuider(newOrigin, lastNode, label) {\r\n        var childBuilder = new StateUpdateBuilder(newOrigin, this._options);\r\n\r\n        //propagate parent builder informations\r\n        childBuilder.parent = this;\r\n        childBuilder._lastNode = lastNode;\r\n        childBuilder._refLabel = label;\r\n\r\n        return childBuilder;\r\n    }\r\n\r\n    //creates new reference for arrays, objects and functions\r\n    extendNode(node) {\r\n        if (Array.isArray(node))\r\n            return [].concat(node);\r\n\r\n        if (typeof node === 'object')\r\n            return Object.assign({}, node);\r\n\r\n        if (typeof node === 'function')\r\n            return ()=> node();\r\n\r\n        return node\r\n    }\r\n\r\n    //traverse single node object\r\n    traverseNode(label) {\r\n        if (this._treeError) return this;\r\n\r\n        var node = this.current[label];\r\n        if (checkNodeUndefined.call(this, node, label))\r\n            return this;\r\n\r\n        //create new builder with shallow copy of traversed node\r\n        var resultBuilder = this.initChildBuider(node, this.current, label);\r\n\r\n        //assign node copy to parent pointer\r\n        this.current[label] = resultBuilder.current;\r\n\r\n        //returns new builder\r\n        return resultBuilder;\r\n    }\r\n\r\n    //traverse single array object navigate to array instance\r\n    traverseList(label, lambda) {\r\n        if (this._treeError) return this;\r\n\r\n        var node = this.current[label];\r\n\r\n        if (checkNodeUndefined.call(this, node, label) || checkNodeNotArray.call(this, node, label)) {\r\n            this.propagateError(true);\r\n            return this;\r\n        }\r\n\r\n        var choosePath = (el, i)=> typeof lambda === 'function' ? lambda(el, i) : true;\r\n        var elemIndex = node.findIndex(choosePath);\r\n\r\n        if (checkListItemUndefined.call(this, elemIndex, label)) return this;\r\n\r\n        var lastNode = this.extendNode(node);\r\n        //create new builder positioned on item found\r\n        var resultBuilder = this.initChildBuider(node.find(choosePath), lastNode, elemIndex);\r\n\r\n        //generate new reference to current node array\r\n        this.current[label] = lastNode;\r\n        this.current[label][elemIndex] = resultBuilder.current;\r\n\r\n        return resultBuilder;\r\n    }\r\n\r\n    //UPDATE OPERATIONS\r\n    //{$set: any} replace the target entirely.\r\n    set(label, value) {\r\n        if (this._treeError) return this;\r\n\r\n        if (_DEV_ && this._options.enableWarnings && this.current[label] === undefined && label !== null)\r\n            console.error('SUB - Warning: node \"' + label + '\" not found');\r\n\r\n        this.propagateUpdate(this._updated || this.current[label] !== value);\r\n        this.current[label] = value;\r\n\r\n\r\n        return this;\r\n    }\r\n\r\n    setNode(node) {\r\n        if (this._treeError) return this;\r\n\r\n        if (!this._lastNode) {\r\n            this.current = node;\r\n            this.propagateUpdate(this._updated || this.current !== node);\r\n        }\r\n        else {\r\n            this._lastNode[this._refLabel] = node;\r\n            this.propagateUpdate(this._updated || this._lastNode[this._refLabel] !== node);\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    //{$merge: object} merge the keys of object with the target.\r\n    merge(label, value) {\r\n        if (this._treeError) return this;\r\n\r\n        if (this._options.enableWarnings && typeof value !== 'object') {\r\n            console.error('SUB - Warning: \"value\" is not an object');\r\n            return this;\r\n        }\r\n\r\n        var node = this.current[label];\r\n\r\n        this.propagateUpdate(this._updated || Object.keys(value).reduce((p, c) => p || node[c] !== value[c], false));\r\n\r\n        this.current[label] = Object.assign(node, value);\r\n\r\n\r\n        return this;\r\n    }\r\n\r\n    mergeNode(node) {\r\n        if (this._treeError) return this;\r\n\r\n        var elem = this._lastNode ? this._lastNode[this._refLabel] : this.current;\r\n        this.propagateUpdate(this._updated || Object.keys(node).reduce((p, c) => p || elem[c] !== node[c], false));\r\n\r\n        if (!this._lastNode) {\r\n            this.current = Object.assign(this.current, node);\r\n        }\r\n        else\r\n            this._lastNode[this._refLabel] = Object.assign(this._lastNode[this._refLabel], node);\r\n\r\n        return this;\r\n    }\r\n\r\n    //remove child node of current object/array node\r\n    removeNode(label, lambda) {\r\n        var node = this.current[label];\r\n\r\n        if (node == undefined) return this;\r\n\r\n        if (Array.isArray(node)) {\r\n            var elemIndex = node.findIndex(lambda);\r\n            this.current[label].splice(elemIndex, 1);\r\n            return this;\r\n        }\r\n\r\n        this.current[label] = undefined;\r\n        this.propagateUpdate(true);\r\n\r\n        return this;\r\n    }\r\n\r\n    //{$apply: function} passes in the current value to the function and updates it with the new returned value.\r\n    apply(label, fn) {\r\n        if (this._treeError) return this;\r\n\r\n        var node = this.current[label];\r\n        if (checkNodeUndefined.call(this, node, label) || checkNotFunction.call(this, fn))\r\n            return this;\r\n\r\n        this.current[label] = fn(this.extendNode(node));\r\n\r\n        this.propagateUpdate(this._updated || node !== this.current[label]);\r\n\r\n        return this;\r\n    }\r\n\r\n    //{$push: array} push() all the items in array on the target.\r\n    push(label, array) {\r\n        if (this._treeError) return this;\r\n        var node = this.current[label];\r\n        if (checkNodeUndefined.call(this, node, label) || checkNodeNotArray.call(this, array, label))\r\n            return this;\r\n\r\n        var newNode = this.current[label] = this.extendNode(node);\r\n        Array.prototype.push.apply(newNode, array);\r\n        this.propagateUpdate(true);\r\n\r\n        return this; //returns the same builder\r\n\r\n\r\n    }\r\n\r\n    //{$unshift: array} unshift() all the items in array on the target.\r\n    unshift(label, array) {\r\n        if (this._treeError) return this;\r\n        var node = this.current[label];\r\n        if (checkNodeUndefined.call(this, node, label) || checkNodeNotArray.call(this, array, label))\r\n            return this;\r\n\r\n        var newNode = this.current[label] = this.extendNode(node);\r\n        Array.prototype.unshift.apply(newNode, array);\r\n        this.propagateUpdate(this._updated || array.length > 0);\r\n\r\n        return this; //returns the same builder\r\n    }\r\n\r\n    //{$splice: array of arrays} for each item in arrays call splice() on the target with the parameters provided by the item.\r\n    splice(label, array) {\r\n        if (this._treeError) return this;\r\n        var node = this.current[label];\r\n        if (checkNodeUndefined.call(this, node, label) || checkNodeNotArray.call(this, array, label))\r\n            return this;\r\n\r\n        var newNode = this.current[label] = this.extendNode(node);\r\n        Array.prototype.splice.apply(newNode, array);\r\n\r\n        this.propagateUpdate(this._updated || array.length > 0);\r\n\r\n        return this; //returns the same builder\r\n    }\r\n\r\n    execute() {\r\n        return this.parent\r\n            ? this.parent.execute()\r\n            : this._treeError ? this.origin : this.current;\r\n    }\r\n\r\n    checkError() {\r\n        return this._treeError;\r\n    }\r\n\r\n    propagateUpdate(update) {\r\n        this._updated = update;\r\n        if(update)\r\n            this.parent && this.parent.propagateUpdate(update);\r\n    };\r\n\r\n    propagateError(error) {\r\n        this._treeError = error;\r\n        this.parent && this.parent.propagateError(error);\r\n    };\r\n\r\n    resetError() {\r\n        this.propagateError(false);\r\n        return this;\r\n    }\r\n\r\n    checkNodeUpdated() {\r\n        return this._updated;\r\n    }\r\n\r\n    pruneSubtree(label) {\r\n        if (this._treeError) return this;\r\n\r\n        var node = this.current[label];\r\n        if (_DEV_ && this._options.enableWarnings && node === undefined && label !== null)\r\n            console.error('SUB - Warning: node \"' + label + '\" not found');\r\n\r\n        if (node != undefined)\r\n            this.current[label] = this.origin[label];\r\n        else {\r\n            if (this._lastNode == undefined) {\r\n                if (this._options.errorsLog)\r\n                    console.error('SUB - Error: cannot prune node root');\r\n            }\r\n            else\r\n                this._lastNode[this._refLabel] = this.origin;\r\n        }\r\n        return this.parent || this;\r\n    }\r\n}\n/* harmony export (immutable) */ __webpack_exports__[\"default\"] = StateUpdateBuilder;\n\r\n\r\n///ERROR CHECK AND NOTIFICATION\r\nfunction checkNodeUndefined(node, label) {\r\n    if (node != undefined) return false;\r\n\r\n    this.propagateError(true);\r\n    if (this._options.errorsLog)\r\n        console.error('SUB - Error: node \"' + label + '\" not found');\r\n    return true;\r\n}\r\nfunction checkListItemUndefined(elemIndex, label) {\r\n    if (elemIndex !== -1) return false;\r\n\r\n    this.propagateError(true);\r\n    if (this._options.errorsLog)\r\n        console.error('SUB - Error: elem of list \"' + label + '\" not found');\r\n    return true;\r\n}\r\n\r\nfunction checkNodeNotArray(node, label) {\r\n    if (Array.isArray(node)) return false;\r\n\r\n    this.propagateError(true);\r\n    if (this._options.errorsLog)\r\n        console.error('SUB - Error: node \"' + label + '\" is not an array');\r\n    return true;\r\n}\r\n\r\nfunction checkNotFunction(fn) {\r\n    if (typeof fn === 'function') return false;\r\n\r\n    this.propagateError(true);\r\n    if (this._options.errorsLog)\r\n        console.error('SUB - Error: parameter \"fn\" is not a function');\r\n    return true;\r\n}\r\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9pbmRleC5qcz85NTUyIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IGRlZmF1bHRPcHRpb25zID0ge1xyXG4gICAgZW5hYmxlV2FybmluZ3M6IGZhbHNlLFxyXG4gICAgZXJyb3JzTG9nOiB0cnVlXHJcbn07XHJcblxyXG5cclxuLy9UT0RPOiBhZCB3YXJuaW5nc1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTdGF0ZVVwZGF0ZUJ1aWxkZXIge1xyXG4gICAgY29uc3RydWN0b3Ioc3RhdGUsIG9wdGlvbnMpIHtcclxuICAgICAgICBpZiAoc3RhdGUgPT0gdW5kZWZpbmVkKVxyXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdyb290IGNhbm5vdCBiZSBudWxsJyk7XHJcblxyXG4gICAgICAgIHRoaXMuX29wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0T3B0aW9ucywgb3B0aW9ucyk7XHJcblxyXG4gICAgICAgIHRoaXMuY3VycmVudCA9IHRoaXMuZXh0ZW5kTm9kZShzdGF0ZSk7XHJcbiAgICAgICAgdGhpcy5vcmlnaW4gPSBzdGF0ZTtcclxuICAgICAgICB0aGlzLnBhcmVudCA9IHVuZGVmaW5lZDtcclxuICAgICAgICB0aGlzLnBhcmVudCA9IHVuZGVmaW5lZDtcclxuICAgICAgICB0aGlzLl91cGRhdGVkID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5fbGFzdE5vZGUgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgdGhpcy5fcmVmTGFiZWwgPSB1bmRlZmluZWQ7XHJcbiAgICB9XHJcblxyXG4gICAgLy9nZW5lcmF0ZSBhIFN0YXRlVXBkYXRlQnVpbGRlciBhcyBwYXNzaW5nIGN1cnJlbnQgcm9vdCBhcyBhblxyXG4gICAgaW5pdENoaWxkQnVpZGVyKG5ld09yaWdpbiwgbGFzdE5vZGUsIGxhYmVsKSB7XHJcbiAgICAgICAgdmFyIGNoaWxkQnVpbGRlciA9IG5ldyBTdGF0ZVVwZGF0ZUJ1aWxkZXIobmV3T3JpZ2luLCB0aGlzLl9vcHRpb25zKTtcclxuXHJcbiAgICAgICAgLy9wcm9wYWdhdGUgcGFyZW50IGJ1aWxkZXIgaW5mb3JtYXRpb25zXHJcbiAgICAgICAgY2hpbGRCdWlsZGVyLnBhcmVudCA9IHRoaXM7XHJcbiAgICAgICAgY2hpbGRCdWlsZGVyLl9sYXN0Tm9kZSA9IGxhc3ROb2RlO1xyXG4gICAgICAgIGNoaWxkQnVpbGRlci5fcmVmTGFiZWwgPSBsYWJlbDtcclxuXHJcbiAgICAgICAgcmV0dXJuIGNoaWxkQnVpbGRlcjtcclxuICAgIH1cclxuXHJcbiAgICAvL2NyZWF0ZXMgbmV3IHJlZmVyZW5jZSBmb3IgYXJyYXlzLCBvYmplY3RzIGFuZCBmdW5jdGlvbnNcclxuICAgIGV4dGVuZE5vZGUobm9kZSkge1xyXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KG5vZGUpKVxyXG4gICAgICAgICAgICByZXR1cm4gW10uY29uY2F0KG5vZGUpO1xyXG5cclxuICAgICAgICBpZiAodHlwZW9mIG5vZGUgPT09ICdvYmplY3QnKVxyXG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgbm9kZSk7XHJcblxyXG4gICAgICAgIGlmICh0eXBlb2Ygbm9kZSA9PT0gJ2Z1bmN0aW9uJylcclxuICAgICAgICAgICAgcmV0dXJuICgpPT4gbm9kZSgpO1xyXG5cclxuICAgICAgICByZXR1cm4gbm9kZVxyXG4gICAgfVxyXG5cclxuICAgIC8vdHJhdmVyc2Ugc2luZ2xlIG5vZGUgb2JqZWN0XHJcbiAgICB0cmF2ZXJzZU5vZGUobGFiZWwpIHtcclxuICAgICAgICBpZiAodGhpcy5fdHJlZUVycm9yKSByZXR1cm4gdGhpcztcclxuXHJcbiAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmN1cnJlbnRbbGFiZWxdO1xyXG4gICAgICAgIGlmIChjaGVja05vZGVVbmRlZmluZWQuY2FsbCh0aGlzLCBub2RlLCBsYWJlbCkpXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgICAgICAvL2NyZWF0ZSBuZXcgYnVpbGRlciB3aXRoIHNoYWxsb3cgY29weSBvZiB0cmF2ZXJzZWQgbm9kZVxyXG4gICAgICAgIHZhciByZXN1bHRCdWlsZGVyID0gdGhpcy5pbml0Q2hpbGRCdWlkZXIobm9kZSwgdGhpcy5jdXJyZW50LCBsYWJlbCk7XHJcblxyXG4gICAgICAgIC8vYXNzaWduIG5vZGUgY29weSB0byBwYXJlbnQgcG9pbnRlclxyXG4gICAgICAgIHRoaXMuY3VycmVudFtsYWJlbF0gPSByZXN1bHRCdWlsZGVyLmN1cnJlbnQ7XHJcblxyXG4gICAgICAgIC8vcmV0dXJucyBuZXcgYnVpbGRlclxyXG4gICAgICAgIHJldHVybiByZXN1bHRCdWlsZGVyO1xyXG4gICAgfVxyXG5cclxuICAgIC8vdHJhdmVyc2Ugc2luZ2xlIGFycmF5IG9iamVjdCBuYXZpZ2F0ZSB0byBhcnJheSBpbnN0YW5jZVxyXG4gICAgdHJhdmVyc2VMaXN0KGxhYmVsLCBsYW1iZGEpIHtcclxuICAgICAgICBpZiAodGhpcy5fdHJlZUVycm9yKSByZXR1cm4gdGhpcztcclxuXHJcbiAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmN1cnJlbnRbbGFiZWxdO1xyXG5cclxuICAgICAgICBpZiAoY2hlY2tOb2RlVW5kZWZpbmVkLmNhbGwodGhpcywgbm9kZSwgbGFiZWwpIHx8IGNoZWNrTm9kZU5vdEFycmF5LmNhbGwodGhpcywgbm9kZSwgbGFiZWwpKSB7XHJcbiAgICAgICAgICAgIHRoaXMucHJvcGFnYXRlRXJyb3IodHJ1ZSk7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIGNob29zZVBhdGggPSAoZWwsIGkpPT4gdHlwZW9mIGxhbWJkYSA9PT0gJ2Z1bmN0aW9uJyA/IGxhbWJkYShlbCwgaSkgOiB0cnVlO1xyXG4gICAgICAgIHZhciBlbGVtSW5kZXggPSBub2RlLmZpbmRJbmRleChjaG9vc2VQYXRoKTtcclxuXHJcbiAgICAgICAgaWYgKGNoZWNrTGlzdEl0ZW1VbmRlZmluZWQuY2FsbCh0aGlzLCBlbGVtSW5kZXgsIGxhYmVsKSkgcmV0dXJuIHRoaXM7XHJcblxyXG4gICAgICAgIHZhciBsYXN0Tm9kZSA9IHRoaXMuZXh0ZW5kTm9kZShub2RlKTtcclxuICAgICAgICAvL2NyZWF0ZSBuZXcgYnVpbGRlciBwb3NpdGlvbmVkIG9uIGl0ZW0gZm91bmRcclxuICAgICAgICB2YXIgcmVzdWx0QnVpbGRlciA9IHRoaXMuaW5pdENoaWxkQnVpZGVyKG5vZGUuZmluZChjaG9vc2VQYXRoKSwgbGFzdE5vZGUsIGVsZW1JbmRleCk7XHJcblxyXG4gICAgICAgIC8vZ2VuZXJhdGUgbmV3IHJlZmVyZW5jZSB0byBjdXJyZW50IG5vZGUgYXJyYXlcclxuICAgICAgICB0aGlzLmN1cnJlbnRbbGFiZWxdID0gbGFzdE5vZGU7XHJcbiAgICAgICAgdGhpcy5jdXJyZW50W2xhYmVsXVtlbGVtSW5kZXhdID0gcmVzdWx0QnVpbGRlci5jdXJyZW50O1xyXG5cclxuICAgICAgICByZXR1cm4gcmVzdWx0QnVpbGRlcjtcclxuICAgIH1cclxuXHJcbiAgICAvL1VQREFURSBPUEVSQVRJT05TXHJcbiAgICAvL3skc2V0OiBhbnl9IHJlcGxhY2UgdGhlIHRhcmdldCBlbnRpcmVseS5cclxuICAgIHNldChsYWJlbCwgdmFsdWUpIHtcclxuICAgICAgICBpZiAodGhpcy5fdHJlZUVycm9yKSByZXR1cm4gdGhpcztcclxuXHJcbiAgICAgICAgaWYgKF9ERVZfICYmIHRoaXMuX29wdGlvbnMuZW5hYmxlV2FybmluZ3MgJiYgdGhpcy5jdXJyZW50W2xhYmVsXSA9PT0gdW5kZWZpbmVkICYmIGxhYmVsICE9PSBudWxsKVxyXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdTVUIgLSBXYXJuaW5nOiBub2RlIFwiJyArIGxhYmVsICsgJ1wiIG5vdCBmb3VuZCcpO1xyXG5cclxuICAgICAgICB0aGlzLnByb3BhZ2F0ZVVwZGF0ZSh0aGlzLl91cGRhdGVkIHx8IHRoaXMuY3VycmVudFtsYWJlbF0gIT09IHZhbHVlKTtcclxuICAgICAgICB0aGlzLmN1cnJlbnRbbGFiZWxdID0gdmFsdWU7XHJcblxyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuXHJcbiAgICBzZXROb2RlKG5vZGUpIHtcclxuICAgICAgICBpZiAodGhpcy5fdHJlZUVycm9yKSByZXR1cm4gdGhpcztcclxuXHJcbiAgICAgICAgaWYgKCF0aGlzLl9sYXN0Tm9kZSkge1xyXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnQgPSBub2RlO1xyXG4gICAgICAgICAgICB0aGlzLnByb3BhZ2F0ZVVwZGF0ZSh0aGlzLl91cGRhdGVkIHx8IHRoaXMuY3VycmVudCAhPT0gbm9kZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLl9sYXN0Tm9kZVt0aGlzLl9yZWZMYWJlbF0gPSBub2RlO1xyXG4gICAgICAgICAgICB0aGlzLnByb3BhZ2F0ZVVwZGF0ZSh0aGlzLl91cGRhdGVkIHx8IHRoaXMuX2xhc3ROb2RlW3RoaXMuX3JlZkxhYmVsXSAhPT0gbm9kZSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuXHJcbiAgICAvL3skbWVyZ2U6IG9iamVjdH0gbWVyZ2UgdGhlIGtleXMgb2Ygb2JqZWN0IHdpdGggdGhlIHRhcmdldC5cclxuICAgIG1lcmdlKGxhYmVsLCB2YWx1ZSkge1xyXG4gICAgICAgIGlmICh0aGlzLl90cmVlRXJyb3IpIHJldHVybiB0aGlzO1xyXG5cclxuICAgICAgICBpZiAodGhpcy5fb3B0aW9ucy5lbmFibGVXYXJuaW5ncyAmJiB0eXBlb2YgdmFsdWUgIT09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1NVQiAtIFdhcm5pbmc6IFwidmFsdWVcIiBpcyBub3QgYW4gb2JqZWN0Jyk7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmN1cnJlbnRbbGFiZWxdO1xyXG5cclxuICAgICAgICB0aGlzLnByb3BhZ2F0ZVVwZGF0ZSh0aGlzLl91cGRhdGVkIHx8IE9iamVjdC5rZXlzKHZhbHVlKS5yZWR1Y2UoKHAsIGMpID0+IHAgfHwgbm9kZVtjXSAhPT0gdmFsdWVbY10sIGZhbHNlKSk7XHJcblxyXG4gICAgICAgIHRoaXMuY3VycmVudFtsYWJlbF0gPSBPYmplY3QuYXNzaWduKG5vZGUsIHZhbHVlKTtcclxuXHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG5cclxuICAgIG1lcmdlTm9kZShub2RlKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX3RyZWVFcnJvcikgcmV0dXJuIHRoaXM7XHJcblxyXG4gICAgICAgIHZhciBlbGVtID0gdGhpcy5fbGFzdE5vZGUgPyB0aGlzLl9sYXN0Tm9kZVt0aGlzLl9yZWZMYWJlbF0gOiB0aGlzLmN1cnJlbnQ7XHJcbiAgICAgICAgdGhpcy5wcm9wYWdhdGVVcGRhdGUodGhpcy5fdXBkYXRlZCB8fCBPYmplY3Qua2V5cyhub2RlKS5yZWR1Y2UoKHAsIGMpID0+IHAgfHwgZWxlbVtjXSAhPT0gbm9kZVtjXSwgZmFsc2UpKTtcclxuXHJcbiAgICAgICAgaWYgKCF0aGlzLl9sYXN0Tm9kZSkge1xyXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnQgPSBPYmplY3QuYXNzaWduKHRoaXMuY3VycmVudCwgbm9kZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2VcclxuICAgICAgICAgICAgdGhpcy5fbGFzdE5vZGVbdGhpcy5fcmVmTGFiZWxdID0gT2JqZWN0LmFzc2lnbih0aGlzLl9sYXN0Tm9kZVt0aGlzLl9yZWZMYWJlbF0sIG5vZGUpO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuXHJcbiAgICAvL3JlbW92ZSBjaGlsZCBub2RlIG9mIGN1cnJlbnQgb2JqZWN0L2FycmF5IG5vZGVcclxuICAgIHJlbW92ZU5vZGUobGFiZWwsIGxhbWJkYSkge1xyXG4gICAgICAgIHZhciBub2RlID0gdGhpcy5jdXJyZW50W2xhYmVsXTtcclxuXHJcbiAgICAgICAgaWYgKG5vZGUgPT0gdW5kZWZpbmVkKSByZXR1cm4gdGhpcztcclxuXHJcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkobm9kZSkpIHtcclxuICAgICAgICAgICAgdmFyIGVsZW1JbmRleCA9IG5vZGUuZmluZEluZGV4KGxhbWJkYSk7XHJcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFtsYWJlbF0uc3BsaWNlKGVsZW1JbmRleCwgMSk7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5jdXJyZW50W2xhYmVsXSA9IHVuZGVmaW5lZDtcclxuICAgICAgICB0aGlzLnByb3BhZ2F0ZVVwZGF0ZSh0cnVlKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcblxyXG4gICAgLy97JGFwcGx5OiBmdW5jdGlvbn0gcGFzc2VzIGluIHRoZSBjdXJyZW50IHZhbHVlIHRvIHRoZSBmdW5jdGlvbiBhbmQgdXBkYXRlcyBpdCB3aXRoIHRoZSBuZXcgcmV0dXJuZWQgdmFsdWUuXHJcbiAgICBhcHBseShsYWJlbCwgZm4pIHtcclxuICAgICAgICBpZiAodGhpcy5fdHJlZUVycm9yKSByZXR1cm4gdGhpcztcclxuXHJcbiAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmN1cnJlbnRbbGFiZWxdO1xyXG4gICAgICAgIGlmIChjaGVja05vZGVVbmRlZmluZWQuY2FsbCh0aGlzLCBub2RlLCBsYWJlbCkgfHwgY2hlY2tOb3RGdW5jdGlvbi5jYWxsKHRoaXMsIGZuKSlcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcblxyXG4gICAgICAgIHRoaXMuY3VycmVudFtsYWJlbF0gPSBmbih0aGlzLmV4dGVuZE5vZGUobm9kZSkpO1xyXG5cclxuICAgICAgICB0aGlzLnByb3BhZ2F0ZVVwZGF0ZSh0aGlzLl91cGRhdGVkIHx8IG5vZGUgIT09IHRoaXMuY3VycmVudFtsYWJlbF0pO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuXHJcbiAgICAvL3skcHVzaDogYXJyYXl9IHB1c2goKSBhbGwgdGhlIGl0ZW1zIGluIGFycmF5IG9uIHRoZSB0YXJnZXQuXHJcbiAgICBwdXNoKGxhYmVsLCBhcnJheSkge1xyXG4gICAgICAgIGlmICh0aGlzLl90cmVlRXJyb3IpIHJldHVybiB0aGlzO1xyXG4gICAgICAgIHZhciBub2RlID0gdGhpcy5jdXJyZW50W2xhYmVsXTtcclxuICAgICAgICBpZiAoY2hlY2tOb2RlVW5kZWZpbmVkLmNhbGwodGhpcywgbm9kZSwgbGFiZWwpIHx8IGNoZWNrTm9kZU5vdEFycmF5LmNhbGwodGhpcywgYXJyYXksIGxhYmVsKSlcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcblxyXG4gICAgICAgIHZhciBuZXdOb2RlID0gdGhpcy5jdXJyZW50W2xhYmVsXSA9IHRoaXMuZXh0ZW5kTm9kZShub2RlKTtcclxuICAgICAgICBBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseShuZXdOb2RlLCBhcnJheSk7XHJcbiAgICAgICAgdGhpcy5wcm9wYWdhdGVVcGRhdGUodHJ1ZSk7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzOyAvL3JldHVybnMgdGhlIHNhbWUgYnVpbGRlclxyXG5cclxuXHJcbiAgICB9XHJcblxyXG4gICAgLy97JHVuc2hpZnQ6IGFycmF5fSB1bnNoaWZ0KCkgYWxsIHRoZSBpdGVtcyBpbiBhcnJheSBvbiB0aGUgdGFyZ2V0LlxyXG4gICAgdW5zaGlmdChsYWJlbCwgYXJyYXkpIHtcclxuICAgICAgICBpZiAodGhpcy5fdHJlZUVycm9yKSByZXR1cm4gdGhpcztcclxuICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3VycmVudFtsYWJlbF07XHJcbiAgICAgICAgaWYgKGNoZWNrTm9kZVVuZGVmaW5lZC5jYWxsKHRoaXMsIG5vZGUsIGxhYmVsKSB8fCBjaGVja05vZGVOb3RBcnJheS5jYWxsKHRoaXMsIGFycmF5LCBsYWJlbCkpXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgICAgICB2YXIgbmV3Tm9kZSA9IHRoaXMuY3VycmVudFtsYWJlbF0gPSB0aGlzLmV4dGVuZE5vZGUobm9kZSk7XHJcbiAgICAgICAgQXJyYXkucHJvdG90eXBlLnVuc2hpZnQuYXBwbHkobmV3Tm9kZSwgYXJyYXkpO1xyXG4gICAgICAgIHRoaXMucHJvcGFnYXRlVXBkYXRlKHRoaXMuX3VwZGF0ZWQgfHwgYXJyYXkubGVuZ3RoID4gMCk7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzOyAvL3JldHVybnMgdGhlIHNhbWUgYnVpbGRlclxyXG4gICAgfVxyXG5cclxuICAgIC8veyRzcGxpY2U6IGFycmF5IG9mIGFycmF5c30gZm9yIGVhY2ggaXRlbSBpbiBhcnJheXMgY2FsbCBzcGxpY2UoKSBvbiB0aGUgdGFyZ2V0IHdpdGggdGhlIHBhcmFtZXRlcnMgcHJvdmlkZWQgYnkgdGhlIGl0ZW0uXHJcbiAgICBzcGxpY2UobGFiZWwsIGFycmF5KSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX3RyZWVFcnJvcikgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmN1cnJlbnRbbGFiZWxdO1xyXG4gICAgICAgIGlmIChjaGVja05vZGVVbmRlZmluZWQuY2FsbCh0aGlzLCBub2RlLCBsYWJlbCkgfHwgY2hlY2tOb2RlTm90QXJyYXkuY2FsbCh0aGlzLCBhcnJheSwgbGFiZWwpKVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuXHJcbiAgICAgICAgdmFyIG5ld05vZGUgPSB0aGlzLmN1cnJlbnRbbGFiZWxdID0gdGhpcy5leHRlbmROb2RlKG5vZGUpO1xyXG4gICAgICAgIEFycmF5LnByb3RvdHlwZS5zcGxpY2UuYXBwbHkobmV3Tm9kZSwgYXJyYXkpO1xyXG5cclxuICAgICAgICB0aGlzLnByb3BhZ2F0ZVVwZGF0ZSh0aGlzLl91cGRhdGVkIHx8IGFycmF5Lmxlbmd0aCA+IDApO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpczsgLy9yZXR1cm5zIHRoZSBzYW1lIGJ1aWxkZXJcclxuICAgIH1cclxuXHJcbiAgICBleGVjdXRlKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnBhcmVudFxyXG4gICAgICAgICAgICA/IHRoaXMucGFyZW50LmV4ZWN1dGUoKVxyXG4gICAgICAgICAgICA6IHRoaXMuX3RyZWVFcnJvciA/IHRoaXMub3JpZ2luIDogdGhpcy5jdXJyZW50O1xyXG4gICAgfVxyXG5cclxuICAgIGNoZWNrRXJyb3IoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RyZWVFcnJvcjtcclxuICAgIH1cclxuXHJcbiAgICBwcm9wYWdhdGVVcGRhdGUodXBkYXRlKSB7XHJcbiAgICAgICAgdGhpcy5fdXBkYXRlZCA9IHVwZGF0ZTtcclxuICAgICAgICBpZih1cGRhdGUpXHJcbiAgICAgICAgICAgIHRoaXMucGFyZW50ICYmIHRoaXMucGFyZW50LnByb3BhZ2F0ZVVwZGF0ZSh1cGRhdGUpO1xyXG4gICAgfTtcclxuXHJcbiAgICBwcm9wYWdhdGVFcnJvcihlcnJvcikge1xyXG4gICAgICAgIHRoaXMuX3RyZWVFcnJvciA9IGVycm9yO1xyXG4gICAgICAgIHRoaXMucGFyZW50ICYmIHRoaXMucGFyZW50LnByb3BhZ2F0ZUVycm9yKGVycm9yKTtcclxuICAgIH07XHJcblxyXG4gICAgcmVzZXRFcnJvcigpIHtcclxuICAgICAgICB0aGlzLnByb3BhZ2F0ZUVycm9yKGZhbHNlKTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuXHJcbiAgICBjaGVja05vZGVVcGRhdGVkKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl91cGRhdGVkO1xyXG4gICAgfVxyXG5cclxuICAgIHBydW5lU3VidHJlZShsYWJlbCkge1xyXG4gICAgICAgIGlmICh0aGlzLl90cmVlRXJyb3IpIHJldHVybiB0aGlzO1xyXG5cclxuICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3VycmVudFtsYWJlbF07XHJcbiAgICAgICAgaWYgKF9ERVZfICYmIHRoaXMuX29wdGlvbnMuZW5hYmxlV2FybmluZ3MgJiYgbm9kZSA9PT0gdW5kZWZpbmVkICYmIGxhYmVsICE9PSBudWxsKVxyXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdTVUIgLSBXYXJuaW5nOiBub2RlIFwiJyArIGxhYmVsICsgJ1wiIG5vdCBmb3VuZCcpO1xyXG5cclxuICAgICAgICBpZiAobm9kZSAhPSB1bmRlZmluZWQpXHJcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFtsYWJlbF0gPSB0aGlzLm9yaWdpbltsYWJlbF07XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9sYXN0Tm9kZSA9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9vcHRpb25zLmVycm9yc0xvZylcclxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdTVUIgLSBFcnJvcjogY2Fubm90IHBydW5lIG5vZGUgcm9vdCcpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgIHRoaXMuX2xhc3ROb2RlW3RoaXMuX3JlZkxhYmVsXSA9IHRoaXMub3JpZ2luO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5wYXJlbnQgfHwgdGhpcztcclxuICAgIH1cclxufVxyXG5cclxuLy8vRVJST1IgQ0hFQ0sgQU5EIE5PVElGSUNBVElPTlxyXG5mdW5jdGlvbiBjaGVja05vZGVVbmRlZmluZWQobm9kZSwgbGFiZWwpIHtcclxuICAgIGlmIChub2RlICE9IHVuZGVmaW5lZCkgcmV0dXJuIGZhbHNlO1xyXG5cclxuICAgIHRoaXMucHJvcGFnYXRlRXJyb3IodHJ1ZSk7XHJcbiAgICBpZiAodGhpcy5fb3B0aW9ucy5lcnJvcnNMb2cpXHJcbiAgICAgICAgY29uc29sZS5lcnJvcignU1VCIC0gRXJyb3I6IG5vZGUgXCInICsgbGFiZWwgKyAnXCIgbm90IGZvdW5kJyk7XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxufVxyXG5mdW5jdGlvbiBjaGVja0xpc3RJdGVtVW5kZWZpbmVkKGVsZW1JbmRleCwgbGFiZWwpIHtcclxuICAgIGlmIChlbGVtSW5kZXggIT09IC0xKSByZXR1cm4gZmFsc2U7XHJcblxyXG4gICAgdGhpcy5wcm9wYWdhdGVFcnJvcih0cnVlKTtcclxuICAgIGlmICh0aGlzLl9vcHRpb25zLmVycm9yc0xvZylcclxuICAgICAgICBjb25zb2xlLmVycm9yKCdTVUIgLSBFcnJvcjogZWxlbSBvZiBsaXN0IFwiJyArIGxhYmVsICsgJ1wiIG5vdCBmb3VuZCcpO1xyXG4gICAgcmV0dXJuIHRydWU7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNoZWNrTm9kZU5vdEFycmF5KG5vZGUsIGxhYmVsKSB7XHJcbiAgICBpZiAoQXJyYXkuaXNBcnJheShub2RlKSkgcmV0dXJuIGZhbHNlO1xyXG5cclxuICAgIHRoaXMucHJvcGFnYXRlRXJyb3IodHJ1ZSk7XHJcbiAgICBpZiAodGhpcy5fb3B0aW9ucy5lcnJvcnNMb2cpXHJcbiAgICAgICAgY29uc29sZS5lcnJvcignU1VCIC0gRXJyb3I6IG5vZGUgXCInICsgbGFiZWwgKyAnXCIgaXMgbm90IGFuIGFycmF5Jyk7XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxufVxyXG5cclxuZnVuY3Rpb24gY2hlY2tOb3RGdW5jdGlvbihmbikge1xyXG4gICAgaWYgKHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJykgcmV0dXJuIGZhbHNlO1xyXG5cclxuICAgIHRoaXMucHJvcGFnYXRlRXJyb3IodHJ1ZSk7XHJcbiAgICBpZiAodGhpcy5fb3B0aW9ucy5lcnJvcnNMb2cpXHJcbiAgICAgICAgY29uc29sZS5lcnJvcignU1VCIC0gRXJyb3I6IHBhcmFtZXRlciBcImZuXCIgaXMgbm90IGEgZnVuY3Rpb24nKTtcclxuICAgIHJldHVybiB0cnVlO1xyXG59XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9")}])});